var W=Object.defineProperty;var H=(h,f,y)=>f in h?W(h,f,{enumerable:!0,configurable:!0,writable:!0,value:y}):h[f]=y;var r=(h,f,y)=>H(h,typeof f!="symbol"?f+"":f,y);(function(){"use strict";var h=(o=>(o[o.STANDARD=0]="STANDARD",o[o.SHOCKWAVE=1]="SHOCKWAVE",o[o.FLASH=2]="FLASH",o[o.MOLTEN=3]="MOLTEN",o[o.SMOKE=4]="SMOKE",o))(h||{});const f=1,y=2,z=1e5;class N{constructor(t){r(this,"sharedBuffer");r(this,"x");r(this,"y");r(this,"z");r(this,"prevX");r(this,"prevY");r(this,"prevZ");r(this,"vx");r(this,"vy");r(this,"vz");r(this,"life");r(this,"maxLife");r(this,"radius");r(this,"startRadius");r(this,"type");r(this,"flags");r(this,"colorIdx");r(this,"activeIndices");r(this,"activeCount",0);r(this,"nextFreeIdx",0);r(this,"colorPalette",[]);const s=z,l=s*4,n=s*4,c=s+3&-4,u=13*l+1*n+2*c;if(t)this.sharedBuffer=t;else try{this.sharedBuffer=new(window.SharedArrayBuffer||ArrayBuffer)(u)}catch{console.warn("SharedArrayBuffer not available, falling back to main thread physics."),this.sharedBuffer=new ArrayBuffer(u)}let v=0;const e=()=>{const x=new Float32Array(this.sharedBuffer,v,s);return v+=l,x},w=()=>{const x=new Uint32Array(this.sharedBuffer,v,s);return v+=n,x},E=()=>{const x=new Uint8Array(this.sharedBuffer,v,s);return v+=c,x};this.x=e(),this.y=e(),this.z=e(),this.prevX=e(),this.prevY=e(),this.prevZ=e(),this.vx=e(),this.vy=e(),this.vz=e(),this.life=e(),this.maxLife=e(),this.radius=e(),this.startRadius=e(),this.type=E(),this.flags=E(),this.colorIdx=w(),this.activeIndices=new Uint32Array(s)}getNextIndex(){for(let t=0;t<z;t++){const s=(this.nextFreeIdx+t)%z;if(!(this.flags[s]&f))return this.nextFreeIdx=(s+1)%z,s}return-1}clear(){this.flags.fill(0),this.x.fill(0),this.y.fill(0),this.z.fill(0),this.vx.fill(0),this.vy.fill(0),this.vz.fill(0),this.life.fill(0),this.activeCount=0,this.nextFreeIdx=0}}class X{static update(t,s,l,n,c,u,v,e=6.4){const w=[],E=[],x=u?u.windDir.x*u.windSpeed*e:0,b=u?u.windDir.y*u.windSpeed*e:0,U=z;for(let i=0;i<U;i++){if(!(s.flags[i]&f))continue;s.prevX[i]=s.x[i],s.prevY[i]=s.y[i],s.prevZ[i]=s.z[i];const m=s.type[i];if(m===h.SMOKE){const S=-2*e,L=Date.now()*.001+i,M=Math.sin(L*2)*1.5*e,I=Math.cos(L*1.5)*.8*e;s.vx[i]+=(x+M-s.vx[i]*.5)*t,s.vy[i]+=(b+S+I-s.vy[i]*.5)*t,s.x[i]+=s.vx[i]*t,s.y[i]+=s.vy[i]*t;const B=s.life[i]/s.maxLife[i];s.radius[i]=s.startRadius[i]+(1-B)*(s.startRadius[i]*2)}else if(m===h.STANDARD||m===h.MOLTEN){const S=s.x[i]+s.vx[i]*t,L=s.y[i]+s.vy[i]*t,M=s.flags[i]&y,I=l.isWall(S,L);if(M&&I?(s.vx[i]=0,s.vy[i]=0,s.life[i]*=.5):m===h.MOLTEN&&I?(s.vx[i]*=-.3,s.vy[i]*=-.3):(s.x[i]=S,s.y[i]=L),m===h.MOLTEN){const B=9.81*e;if(s.vz[i]+=B*t,s.z[i]+=s.vz[i]*t,s.vx[i]*=.995,s.vy[i]*=.995,s.z[i]>0&&s.vz[i]>0&&(s.z[i]!==0&&v&&E.push({x:s.x[i],y:s.y[i],intensity:.6,radius:20}),s.z[i]=0,s.vz[i]=0,s.vx[i]=0,s.vy[i]=0),s.z[i]<-2){if(n&&n.active){const g=n.x-s.x[i],A=n.y-s.y[i],p=n.radius+s.radius[i];g*g+A*A<p*p&&(w.push({targetIdx:-1,damage:5}),s.flags[i]&=~f)}if(s.flags[i]&f)for(let g=0;g<c.length;g++){const A=c[g],p=A.x-s.x[i],O=A.y-s.y[i],C=A.radius+s.radius[i];if(p*p+O*O<C*C){w.push({targetIdx:g,damage:5}),s.flags[i]&=~f;break}}}}else s.vx[i]*=.95,s.vy[i]*=.95}if(s.life[i]-=t,s.life[i]<=0&&(s.flags[i]&=~f),s.flags[i]&f){const S=s.life[i]/s.maxLife[i];s.flags[i]&y&&(s.radius[i]=s.startRadius[i]+(1-S)*10)}}return{damageEvents:w,heatEvents:E}}}let D=null,F=null,R=!0;class Y{constructor(t,s,l,n){this.width=t,this.height=s,this.tileSize=l,this.tiles=n}isWall(t,s){const l=Math.floor(t/this.tileSize),n=Math.floor(s/this.tileSize);return l<0||l>=this.width||n<0||n>=this.height?!0:this.tiles[n*this.width+l]!==0}}self.onmessage=o=>{const{type:t,data:s}=o.data;if(t==="init"){const{buffer:l,worldData:n,role:c}=s;c!==void 0&&(R=c==="host"||c==="single"),D=new N(l),n&&(F=new Y(n.width,n.height,n.tileSize,new Uint8Array(n.tilesBuffer)))}else if(t==="update"){if(!D||!F)return;const{dt:l,player:n,enemies:c,weather:u,pixelsPerMeter:v}=s,e=X.update(l,D,F,n,c,u,R,v);self.postMessage({type:"updated"}),(e.damageEvents.length>0||e.heatEvents.length>0)&&self.postMessage({type:"events",data:e})}}})();
