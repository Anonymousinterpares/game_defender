var U=Object.defineProperty;var W=(h,o,y)=>o in h?U(h,o,{enumerable:!0,configurable:!0,writable:!0,value:y}):h[o]=y;var n=(h,o,y)=>W(h,typeof o!="symbol"?o+"":o,y);(function(){"use strict";var h=(f=>(f[f.STANDARD=0]="STANDARD",f[f.SHOCKWAVE=1]="SHOCKWAVE",f[f.FLASH=2]="FLASH",f[f.MOLTEN=3]="MOLTEN",f[f.SMOKE=4]="SMOKE",f))(h||{});const o=1,y=2,A=1e5;class N{constructor(e){n(this,"sharedBuffer");n(this,"x");n(this,"y");n(this,"z");n(this,"prevX");n(this,"prevY");n(this,"prevZ");n(this,"vx");n(this,"vy");n(this,"vz");n(this,"life");n(this,"maxLife");n(this,"radius");n(this,"startRadius");n(this,"type");n(this,"flags");n(this,"colorIdx");n(this,"activeIndices");n(this,"activeCount",0);n(this,"nextFreeIdx",0);n(this,"colorPalette",[]);const s=A,l=s*4,t=s*4,u=s+3&-4,v=13*l+1*t+2*u;if(e)this.sharedBuffer=e;else try{this.sharedBuffer=new(window.SharedArrayBuffer||ArrayBuffer)(v)}catch{console.warn("SharedArrayBuffer not available, falling back to main thread physics."),this.sharedBuffer=new ArrayBuffer(v)}let c=0;const r=()=>{const x=new Float32Array(this.sharedBuffer,c,s);return c+=l,x},M=()=>{const x=new Uint32Array(this.sharedBuffer,c,s);return c+=t,x},m=()=>{const x=new Uint8Array(this.sharedBuffer,c,s);return c+=u,x};this.x=r(),this.y=r(),this.z=r(),this.prevX=r(),this.prevY=r(),this.prevZ=r(),this.vx=r(),this.vy=r(),this.vz=r(),this.life=r(),this.maxLife=r(),this.radius=r(),this.startRadius=r(),this.type=m(),this.flags=m(),this.colorIdx=M(),this.activeIndices=new Uint32Array(s)}getNextIndex(){for(let e=0;e<A;e++){const s=(this.nextFreeIdx+e)%A;if(!(this.flags[s]&o))return this.nextFreeIdx=(s+1)%A,s}return-1}clear(){this.flags.fill(0),this.x.fill(0),this.y.fill(0),this.z.fill(0),this.vx.fill(0),this.vy.fill(0),this.vz.fill(0),this.life.fill(0),this.activeCount=0,this.nextFreeIdx=0}}class Y{static update(e,s,l,t,u,v,c){const r=[],M=[],m=v?v.windDir.x*v.windSpeed:0,x=v?v.windDir.y*v.windSpeed:0,b=A;for(let i=0;i<b;i++){if(!(s.flags[i]&o))continue;s.prevX[i]=s.x[i],s.prevY[i]=s.y[i],s.prevZ[i]=s.z[i];const z=s.type[i];if(z===h.SMOKE){const p=Date.now()*.001+i,F=Math.sin(p*2)*10,L=Math.cos(p*1.5)*5;s.vx[i]+=(m*20+F-s.vx[i]*.5)*e,s.vy[i]+=(x*20+-15+L-s.vy[i]*.5)*e,s.x[i]+=s.vx[i]*e,s.y[i]+=s.vy[i]*e;const R=s.life[i]/s.maxLife[i];s.radius[i]=s.startRadius[i]+(1-R)*(s.startRadius[i]*2)}else if(z===h.STANDARD||z===h.MOLTEN){const w=s.x[i]+s.vx[i]*e,p=s.y[i]+s.vy[i]*e,F=s.flags[i]&y,L=l.isWall(w,p);if(F&&L?(s.vx[i]=0,s.vy[i]=0,s.life[i]*=.5):z===h.MOLTEN&&L?(s.vx[i]*=-.3,s.vy[i]*=-.3):(s.x[i]=w,s.y[i]=p),z===h.MOLTEN){if(s.vz[i]+=80*e,s.z[i]+=s.vz[i]*e,s.vx[i]*=.995,s.vy[i]*=.995,s.z[i]>0&&s.vz[i]>0&&(s.z[i]!==0&&c&&M.push({x:s.x[i],y:s.y[i],intensity:.6,radius:20}),s.z[i]=0,s.vz[i]=0,s.vx[i]=0,s.vy[i]=0),s.z[i]<-2){if(t&&t.active){const g=t.x-s.x[i],S=t.y-s.y[i],E=t.radius+s.radius[i];g*g+S*S<E*E&&(r.push({targetIdx:-1,damage:5}),s.flags[i]&=~o)}if(s.flags[i]&o)for(let g=0;g<u.length;g++){const S=u[g],E=S.x-s.x[i],O=S.y-s.y[i],C=S.radius+s.radius[i];if(E*E+O*O<C*C){r.push({targetIdx:g,damage:5}),s.flags[i]&=~o;break}}}}else s.vx[i]*=.95,s.vy[i]*=.95}if(s.life[i]-=e,s.life[i]<=0&&(s.flags[i]&=~o),s.flags[i]&o){const w=s.life[i]/s.maxLife[i];s.flags[i]&y&&(s.radius[i]=s.startRadius[i]+(1-w)*10)}}return{damageEvents:r,heatEvents:M}}}let I=null,D=null,B=!0;class X{constructor(e,s,l,t){this.width=e,this.height=s,this.tileSize=l,this.tiles=t}isWall(e,s){const l=Math.floor(e/this.tileSize),t=Math.floor(s/this.tileSize);return l<0||l>=this.width||t<0||t>=this.height?!0:this.tiles[t*this.width+l]!==0}}self.onmessage=f=>{const{type:e,data:s}=f.data;if(e==="init"){const{buffer:l,worldData:t,role:u}=s;u!==void 0&&(B=u==="host"||u==="single"),I=new N(l),t&&(D=new X(t.width,t.height,t.tileSize,new Uint8Array(t.tilesBuffer)))}else if(e==="update"){if(!I||!D)return;const{dt:l,player:t,enemies:u,weather:v}=s,c=Y.update(l,I,D,t,u,v,B);self.postMessage({type:"updated"}),(c.damageEvents.length>0||c.heatEvents.length>0)&&self.postMessage({type:"events",data:c})}}})();
